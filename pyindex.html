<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hand Gesture Detection</title>
  <style>
    canvas {
      display: block;
      margin: auto;
      border: 1px solid #ddd;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
</head>
<body>
  <video id="video" autoplay playsinline style="display: none;"></video>
  <canvas id="output"></canvas>

  <script>
    const videoElement = document.getElementById('video');
    const canvasElement = document.getElementById('output');
    const canvasCtx = canvasElement.getContext('2d');

    // Mediapipe Hands setup
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    hands.onResults(onResults);

    // Function to process video frames
    async function startVideo() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      videoElement.srcObject = stream;
      videoElement.play();

      // Set up a processing loop
      function processFrame() {
        if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
          canvasElement.width = videoElement.videoWidth;
          canvasElement.height = videoElement.videoHeight;

          canvasCtx.save();
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
          canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
          hands.send({ image: videoElement });
          canvasCtx.restore();
        }
        requestAnimationFrame(processFrame);
      }
      processFrame();
    }

    function onResults(results) {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        for (const landmarks of results.multiHandLandmarks) {
          // Draw landmarks and connections
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
          drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });

          // Gesture Detection
          const gesture = detectGesture(landmarks);
          canvasCtx.fillStyle = 'green';
          canvasCtx.font = '24px Arial';
          canvasCtx.fillText(`Gesture: ${gesture}`, 10, 30);
        }
      }
    }

    function detectGesture(landmarks) {
      const [thumb, index, middle, ring, pinky] = [
        landmarks[4],  // Thumb tip
        landmarks[8],  // Index tip
        landmarks[12], // Middle tip
        landmarks[16], // Ring tip
        landmarks[20], // Pinky tip
      ];

      const isFingerExtended = (tip, joint) => tip.y < joint.y;

      const thumbExtended = thumb.x > landmarks[3].x;
      const indexExtended = isFingerExtended(index, landmarks[6]);
      const middleExtended = isFingerExtended(middle, landmarks[10]);
      const ringExtended = isFingerExtended(ring, landmarks[14]);
      const pinkyExtended = isFingerExtended(pinky, landmarks[18]);

      const allFingers = [thumbExtended, indexExtended, middleExtended, ringExtended, pinkyExtended];

      if (allFingers.every(Boolean)) return 'Open Hand';
      if (allFingers.every((f) => !f)) return 'Closed Hand';
      if (indexExtended && pinkyExtended && !middleExtended && !ringExtended) return 'Rock & Roll';
      if (thumbExtended && !allFingers.slice(1).some(Boolean)) return 'Thumbs Up';

      return 'Neutral';
    }

    // Start the video stream
    startVideo();
  </script>
</body>
</html>
